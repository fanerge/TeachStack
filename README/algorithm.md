# 基础

数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。

10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；
10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。

## 复杂度分析

### 大 O 复杂度表示法

```
T(n) = O(f(n))
T(n)表示代码执行的时间
n 表示数据规模的大小
f(n) 表示每行代码执行的次数总和
```

### 时间复杂度（渐进时间复杂度）分析

代码执行时间随数据规模增长的变化趋势。

1.  只关注循环执行次数最多的一段代码
2.  加法法则：总复杂度等于量级最大的那段代码的复杂度
3.  乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

```
O(1) // 常量阶
O(logn)、O(nlogn) // 对数阶，（归并排序、快速排序）
O(m+n)、O(m*n) // 多个循环并列或嵌套
```

### 空间复杂度（渐进空间复杂度）分析

我们说空间复杂度，是指除了原本的数据存储空间外，算法运行还需要额外的存储空间。

算法的执行时间与数据规模之间的增长关系。
代码执行需要申请空间的大小。

```
O(1) // 只需要常量级空间
O(1)、O(logn)、O(n)、O(nlogn)、O(n2)
```

### 最好、最坏、平均、均摊时间复杂度

```
最好情况时间复杂度（best case time complexity）:最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度。
最坏情况时间复杂度（worst case time complexity）:最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度。
平均情况时间复杂度（average case time complexity）:平均时间复杂度的全称应该叫加权平均时间复杂度或者期望时间复杂度。（需要为增加每种情况出现的概率）
均摊时间复杂度（amortized time complexity）:摊还分析法
```

# 数据结构

## 数组（Array）

数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。<br>
线性表（Linear List）：线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。<br>
非线性表：比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。

### 随机访问数组快的原因？

```
const a:any[] = [];
大部分数组都是连续空间，base_address为初始地址，下标是相对于初始地址的offset，所以通过公式
一维数组内存寻址：a[i]_address = base_address + i * data_type_size
可以很快求出i的存放地址，所以随机访问速度快。
// 二维数组内存寻址
对于 m * n 的数组，a [ i ][ j ] (i < m,j < n)的地址为：
a[i]_address = base_address + (i * n + j) * data_type_size
```

### 数组的“插入”和“删除”低效？

假设数组的长度为 n，现在，如果我们需要将一个数据插入到数组中的第 k 个位置。为了把第 k 个位置腾出来，给新来的数据，我们需要将第 k ～ n 这部分的元素都顺序地往后挪一位。

## 链表（Linked list）

链表并不需要一块连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用。

### 单链表

我们把内存块称为链表的“结点”。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址叫作后继指针 next，尾结点的指针指向空地址 NULL。

### 循环链表

它跟单链表唯一的区别就在尾结点。
尾结点特殊的地方是：单链表指针指向一个空地址 NULL，而循环链表的尾结点指针是指向链表的头结点。

### 双向链表（应用比较广）

它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。

### 双向循环链表

循环链表 + 双向链表

### 双向链表删除操作比单链表快？

虽然删除操作的时间复杂度是 O(1)，但是需要遍历去找需要删除元素（删除结点中“值等于某个给定值”的结点、删除给定指针指向的结点）。<br>
对于删除结点中“值等于某个给定值”的结点，单链表需要遍历查找的时间是主要的耗时点，对应的时间复杂度为 O(n)。
删除给定指针指向的结点，单链表没有 prev 指针所以并不支持直接获取前驱结点，所以为了找到前驱结点，我们还是要从头结点开始遍历链表，直到 p->next=q，说明 p 是 q 的前驱结点。

### 如何用链表来实现 LRU 缓存淘汰策略呢？

LRU 是 Least Recently Used 的缩写，即最近最少使用，是一种常用的页面置换算法，选择最近最久未使用的页面予以淘汰。

1. 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。
2. 如果此数据没有在缓存链表中，又可以分为两种情况：如果此时缓存未满，则将此结点直接插入到链表的头部；如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。

### 写链表代码技巧

1.  理解指针或引用的含义：将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。
2.  警惕指针丢失和内存泄漏，删除链表结点时，也一定要记得手动释放内存空间
3.  利用哨兵简化实现难度
4.  重点留意边界条件处理
5.  举例画图，辅助思考

重点留意边界条件处理

```
如果链表为空时，代码是否能正常工作？
如果链表只包含一个结点时，代码是否能正常工作？
如果链表只包含两个结点时，代码是否能正常工作？
代码逻辑在处理头结点和尾结点的时候，是否能正常工作？
```

指针丢失

```
// 例如在a结点和b结点中插入x结点（避免指针丢失，应该将结点 x 的 next 指针指向结点 b，再把结点 a 的 next 指针指向结点 x，这样才不会丢失指针，导致内存泄漏。 ）
p->next = x;  // 将p的next指针指向x结点；// 指针迎接丢失了
x->next = p->next;  // 将x的结点的next指针指向b结点；
```

### 常见的链表考题

```
单链表反转
链表中环的检测
两个有序的链表合并
删除链表倒数第 n 个结点
求链表的中间结点
```

#### 单链表操作

针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。

```
// 空链表插入
if (head == null) {  head = new_node;}
// 非空链表插入
new_node->next = p->next;p->next = new_node;
// 删除尾结点
if (head->next == null) { head = null;}
// 删除非尾结点
p->next = p->next->next;
```

引入哨兵结点，解决上面的问题

```
如果我们引入哨兵结点，在任何时候，不管链表是不是空，head 指针都会一直指向这个哨兵结点。我们也把这种有哨兵结点的链表叫带头链表。相反，没有哨兵结点的链表就叫作不带头链表。
因为哨兵结点一直存在，所以插入第一个结点和插入其他结点，删除最后一个结点和删除其他结点，都可以统一为相同的代码实现逻辑了。
```

## 栈（Stack）

栈只支持两个基本操作：入栈 push()和出栈 pop()。
后进者先出，先进者后出，这就是典型的“栈”结构。<br>
当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构。

### 栈在函数调用中的应用

1.  函数调用栈
2.  表达式求值

```
编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。
如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。
```

3.  括号匹配
4.  浏览器的前进和后退功能/微信小程序路由管理

```
两个栈即可实现（分别放前进后退）
```

## 队列（Queue）

先进者先出，这就是典型的“队列”。
两个操作：入队 enqueue()，放一个数据到队列尾部；出队 dequeue()，从队列头部取一个元素。

### 循环队列

顾名思义，它长得像一个环。原本数组是有头有尾的，是一条直线。现在我们把首尾相连，扳成了一个环。
想写出没有 bug 的循环队列的实现代码，我个人觉得，最关键的是，确定好队空和队满的判定条件。

### 阻塞队列

阻塞队列其实就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。

### 并发队列

最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。

## 递归（Recursion）

递归求解问题的分解过程，去的过程叫“递”，回来的过程叫“归”。

### 递归需要满足的三个条件（同时满足）

1. 一个问题的解可以分解为几个子问题的解
2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样
3. 存在递归终止条件

### 如何编写递归代码？

写出递推公式，找到终止条件。<br>
编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。<br>
递归代码要警惕堆栈溢出。<br>
递归代码要警惕重复计算。<br>
将递归代码改写为非递归代码？迭代循环<br>

## 排序（Sort）

冒泡排序、插入排序、选择排序、归并排序、快速排序、计数排序、基数排序、桶排序。

### 如何分析一个“排序算法”？

1.  排序算法的执行效率
2.  排序算法的内存消耗
3.  排序算法的稳定性

### 冒泡排序（Bubble Sort）

冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。<br>
当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。

#### 有序度

有序度是数组中具有有序关系的元素对的个数。

```
有序元素对：a[i] <= a[j], 如果i < j。
满有序度 = n*(n-1)/2
逆序度 = 满有序度 - 有序度
元素交换的次数是一个固定值，是原始数据的逆序度。
```

### 插入排序（Insertion Sort）

一个有序的数组，我们往里面添加一个新的数据后，我们只要遍历数组，找到数据应该插入的位置将其插入即可。

### 选择排序（Selection Sort）

选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。

---

# 算法方法

## 枚举（部分枚举）

基于已有知识进行答案猜测的一种问题求解策略。
队列为空的判断条件仍然是 head == tail。

### 解题思路

小于 N 的最大‘素数‘，”百钱百鸡”，“熄灯问题”，“讨厌的青蛙”

1.  给出解空间，建立简洁的数学模型（素数的定义）
2.  减少搜索的空间（除 2 以外，只有奇数才有可能为解）
3.  采用合适的搜索顺序空间（从小到大，最大的那一个就为解）

## 递推（类似于求通项公式）

通过已知条件，利用特定关系得出中间推论，直至得到结果的算法。递推算法分为顺推和逆推两种。

### 解题思路

从原点出发，一步只能向右走、向上走或向左走。恰好走 N 步且不经过已走的点共有多少种走法？

```
N = 1时，f(1)=3
N = 2时，f(2)=7
N = 3时，f(3)=17
...
f(n) = 2*f(n-1)+f(n-2) (n>=3)
```

## 递归

某个函数直接或间接的调用自身，把一个问题逐级分解成子问题<br>
背后的数据结构为栈

### 解题思路

斐波那契数列、阶乘、汉诺塔问题、棋盘切割等

1.  递归方程，如何将原问题划分成子问题
2.  递归出口，递归终止的条件，即最小子问题的求解，可以允许多个出口
3.  边界函数，问题规模变化的函数，它保证递归的规模向出口靠拢

## 分治算法（属于递归系列）

分治和动规的区别，分解出的子问题是不重复的使用分治法，如果有的问题分解后的子问题有重复的（重叠子问题性质），的使用动规。<br>
基本思想是将一个规模为 N 的问题分解为 K 个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。<br>
二分法属于分治。

### 解题思路

最经典的归并排序为例，它把待排序数组不断二分为规模更小的子问题处理，这就是“分而治之”这个词的由来。

## 动态规划（属于递归系列）

避免递归中的重复计算，将之前的计算结果保存下来
三个概念：最优子结构、边界、状态转移方程。<br>
一般自底向上更容易理解。

```
// 10步楼梯走法，每次只能走一步或两步
// f(10) = f(9) + f(8);因此，f(9)和f(8)是f(10)的「最优子结构」
// f(1) = 1; f(2) = 2;因此，f(1)、f(2)是问题的「边界」
// f(n) = f(n-1) + f(n-2);被称为「状态转移方程」
```

[10 步楼梯走法](https://juejin.im/post/5a29d52cf265da43333e4da7)

### 解题思路

数字三角形、最长公共子序列

1.  将愿问题分解为子问题（子问题的解需要保存，也就是子问题只需求解一次）
2.  确定状态（我们往往将和子问题相关的各个变量的一组取值，称之为一个“状态”，一个状态对应一个或多个子问题，所谓某个“状态“下的”值”，就是这个“状态”所对应的子问题的解。）
3.  确定一些初始状态（边界状态）的值（以”数字三角形“为例，初始状态就是底边数字，值就是底边数字值）
4.  确定状态转移方程

#### 递归转动规的一般转化方法

递归函数有 n 个参数，就定义一个 n 维的数组，数组的下标是递归函数参数的取值范围，数组元素的值是递归函数的返回值，这样就可以从边界值开始，逐步填充数组，相当于计算递归函数值的逆过程。

## 回溯法

有些实际问题很难归纳出一组简单的递推公式或直观的求解步骤，并且也不能进行无限的列举。对于这类问题，一种有效的方法是“试”。通过对问题的分析，找出一个解决问题的线索，然后沿着这个线索逐步试探，对于每一步试探，若试探成功，就得到问题的解，若试探失败，就逐步回退，换别的路线再进行试探。这种方法称为回朔法。
