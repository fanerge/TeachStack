# 描述JS中基本概念
##  Execution context(EC)
执行环境或执行上下文<br>
执行环境分为三种(全局执行环境，函数执行环境，evel()执行环境)<br>
js为每一个执行环境关联了一个变量对象。环境中定义的所有变量和函数都保存在这个对象中<br>
### Execution context stack(ECS)
执行环境栈(执行上下文栈)<br>
当javascript代码文件被浏览器载入后，默认最先进入的是一个全局的执行上下文。当在全局上下文中调用执行一个函数时，程序流就进入该被调用函数内，此时引擎就会为该函数创建一个新的执行上下文，并且将其压入到执行上下文堆栈的顶部。浏览器总是执行当前在堆栈顶部的上下文，一旦执行完毕，该上下文就会从堆栈顶部被弹出，然后，进入其下的上下文执行代码。这样，堆栈中的上下文就会被依次执行并且弹出堆栈，直到回到全局的上下文。
### EC的组成
```
变量对象（VO）：arguments、variables、functions
[[Scope]]属性：指向作用域链
this指针：指向一个环境对象
```
### 变量对象和活动对象的关系
VO分为全局上下文VO（全局对象，Global object)和函数上下文的AO。<br>
变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object。<br>
它们其实都是同一个对象，只是处于执行环境的不同生命周期。<br>
AO = VO + function parameters + arguments<br>
```
进入执行上下文时，VO的初始化过程具体如下(有先后顺序)：
函数的形参（当进入函数执行上下文时）
—— 变量对象的一个属性，其属性名就是形参的名字，其值就是实参的值；对于没有传递的参数，其值为undefined

函数声明（FunctionDeclaration, FD） —— 变量对象的一个属性，其属性名和值都是函数对象创建出来的；如果变量对象已经包含了相同名字的属性，则替换它的值

变量声明（var，VariableDeclaration） —— 变量对象的一个属性，其属性名即为变量名，其值为undefined;如果变量名和已经声明的函数名或者函数的参数名相同，则不会影响已经存在的属性。
```
### [[Scope]] 作用域
Scope：自己的VO以及所有父执行上下文中的VO一直到全局VO（GO）<br>
f2.EC.Scope = [f2.EC.AO + f2.[[scope]], ...直到全局GO];<br>
// 表示：f2表示函数，f2的EC上的Scope属性等于f2的EC上的AO + f2的静态属性[[scope]]继续向上,<br>
变量的作用域就两种：全局变量和局部变量<br>

> 参考文档：
[javascript 执行环境，变量对象，作用域链](https://segmentfault.com/a/1190000000533094)
[JS 执行环境、作用域链、活动对象](https://segmentfault.com/a/1190000015782315)

## AO对象加载顺序（函数预编译 Activation Object）
1.  函数声明时创建一个AO对象，默认放入arguments对象和this对象（此时均为 undefined）
2.  将函数声明的形参和变量声明放入AO对象，其值为 undefined
3.  将形参和实参进行统一
4.  将所有的函数声明放入AO对象，其值为函数体
5.  开始逐步执行函数，之前的arguments对象和this对象均赋为对应值
   
```
function parent(a, b){
	console.log(a);
	var c = 123;
	console.log(c);
	function a(){};
	console.log(b);
	var b = function c(){};
	console.log(b)
}
test(1, 3);
// 写出对应的输出值
// 根据AO对象加载顺序，分析AO对象变化
// 1
AO {arguments: undefined, this: undefined}
// 2
AO {arguments: undefined, this: undefined, a: undefined, b: undefined, c: undefined}
// 3
AO {arguments: undefined, this: undefined, a: 1, b: 3, c: undefined}
// 4
AO {arguments: undefined, this: undefined, a: function a, b: 3, c: function c, }
// 执行函数过程AO变化
// var c = 123;
AO {arguments: {a: 1, b: 3}, this: window, a: function a, b: 3, c: 123, }
// var b = function c(){}
AO {arguments: {a: 1, b: 3}, this: window, a: function a, b: function c, c: 123, }
// 输出结果
function a
123
3
function c
```
## GO对象加载顺序（预编译）
1.  创建一个GO对象，this = window || global
2.  变量声明放入GO对象，其值为 undefined
3.  将所有的函数声明放入AO对象，其值为函数体
4.  开始逐行执行

```
function a() {
  function b() {
    var bb = 234;
  }
  var aa = 123;
  b();
}
console.log(glob); // function glob
var glob = 100;
console.log(glob); // 100
function glob() {}
console.log(glob); // 100
a()

// 分析GO对象变化
// 1
GO {this: undefined}
// 2
GO {this: undefined, glob:undefined}
// 3
GO {this: undefined, glob: function glob}
// 执行到第一个console.log(glob);
GO {this: undefined, glob: function glob}
// 执行到第二三个console.log(glob);
GO {this: undefined, glob: 100}
```

# V8工作原理
V8 在运行之前将 JavaScript 编译成了机器代码，而非字节码或是解释执行它，以此提升性能。
##  Handle
handle 是指向对象的指针，在 V8 中，所有的对象都通过 handle 来引用，handle 主要用于 V8 的垃圾回收机制。<br>
handle 分为两种：持久化 (Persistent)handle 和本地 (Local)handle，持久化 handle 存放在堆上，而本地 handle 存放在栈上。<br>
在 V8 中，所有数据访问均需要通过 handle。<br>
###  在C++中栈 Stack 和堆 Heap 
Stack：栈上的为自动变量，在退出函数或方法之后自动被释放。<br>
Heap：堆上的空间需要开发人员自己申请，使用完成之后显式的释放。<br>
##  HandleScope
一个函数中，可以有很多 Handle，而 HandleScope 则相当于用来装Handle（Local）的容器，当HandleScope生命周期结束的时候，Handle也将会被释放，会引起Heap中对象引用的更新。<br>
HandleScope是分配在栈上，不能通过New的方式进行创建。对于同一个作用域内可以有多个HandleScope，新的HandleScope将会覆盖上一个HandleScope，并对Local Handle进行管理。<br>
##  Context
Context是V8中一个非常重要的类。<br>
Context中包了JavaScript内建函数、对象等。<br>
context 是一个执行器环境，使用 context 可以将相互分离的 JavaScript 脚本在同一个 V8 实例中运行，而互不干涉。在运行 JavaScript 脚本时，需要显式的指定 context 对象。
##  数据及模板
由于 C++ 原生数据类型与 JavaScript 中数据类型有很大差异，
因此 V8 提供了 Data 类，从 JavaScript 到 C++，从 C++ 到 JavaScrpt 都会用到这个类及其子类。<br>
V8 中，有两个模板 (Template) 类：对象模板 (ObjectTempalte) 和函数模板 (FunctionTemplate):<br>
ObjectTemplate：将 C++ 中的对象暴露给脚本环境<br>
FunctionTemplate：将 C++ 函数暴露给脚本环境，以供脚本使用
##  V8 引擎的应用程序的基本流程
1.  创建 HandleScope 实例
2.  创建一个持久化的 Context
3.  进入 Context
4.  创建脚本字符串（这里就是我们的js代码）
5.  创建 Script 对象，通过 Script::Compile()
6.  执行脚本对象的 Run 方法
7.  获取处理结果
8.  显式的调用 Context 的 Dispose 方法
##  TurboFan & Ignition
其中 Turbofan 是新的优化编译器，而 Ignition 则是新的解释器。

[Google V8 引擎 原理详解](https://blog.csdn.net/jklfjsdj79hiofo/article/details/7842177)

#   对象
##  对象的三个指针
V8的对象主要由三个指针构成，分别是隐藏类（Hidden Class），Property 还有 Element。<br>
###  Hidden class（Shape）
V8会为每个对象初始化时附加一个隐藏类，隐藏类的目的是优化属性访问时间，当添加一个属性时（非索引属性），会产生一个新的隐藏类，该隐藏类继承至原先的隐藏类。<br>
主要为类似的对象（同一构造函数、类的实例，主要是保证相同的顺序初始化对象成员）提供相同的 Shape，用来提升属性的存取性能。<br>
每次添加属性时，新创建 Hidden Class 实际上只会描述这个新添加的属性（增加或删除可索引属性，不会引起隐藏类的变化）。<br>
delete 非索引属性可以会产生新的 Hidden Class ，而 obj[待删除的属性] = undefined 不会 <br>
[8中的Javascript隐藏类和内联缓存](https://richardartoul.github.io/jekyll/update/2015/04/26/hidden-classes.html)
####  Hidden Class 如何优化了对象属性的访问性能？
1.  Hidden Class 描述了可以找到属性的内存中的位置（相对于对象指针）
2.  如果两个对象添加属性的顺序相同，则他们共用一个 Hidden Class，这样就可以快速访问属性
###  Elements
可索引属性会被存储到 Elements 指针指向的区域（遍历时会自动按升序）<br>
```
{ 1: "a", 2: "b" }
```
###  Properties
命名属性会被存储到 Properties 指针指向的区域（会按写入对象的顺序）<br>
```
{ "first": 1, "second": 2 }
```
[V8 是怎么跑起来的 —— V8 中的对象表示](https://juejin.im/post/5cc7dc5af265da038d0b514d)
##  Inline Cache（内联缓存）
内联缓存的目标是通过记住以前直接在调用点上方法查询的结果来加快运行时方法绑定的速度。<br>
内联缓存依赖于对相同方法的重复调用往往发生在同一类型对象上的优化。<br>
### 内联缓存和 Hidden Class 需要配合工作
每当在特定对象上调用方法时，V8引擎必须执行对该对象隐藏类的查找，以确定访问特定属性的偏移量。在将同一方法成功调用两次到同一个隐藏类之后，V8省略了隐藏类查找，只是将属性的偏移量添加到对象指针本身。对于该方法的所有未来调用，V8引擎假定隐藏类未更改，并使用先前查找中存储的偏移直接跳转到特定属性的内存地址; 这大大提高了执行速度。
[内联缓存](https://zh.wikipedia.org/wiki/%E5%86%85%E8%81%94%E7%BC%93%E5%AD%98)
##  对象优化
始终以相同的顺序实例化对象属性，以便可以共享隐藏的类和随后优化的代码。<br>
在实例化之后向对象添加属性将强制隐藏类更改并减慢为先前隐藏类优化的任何方法。而是在其构造函数中分配所有对象的属性。<br>
重复执行相同方法的代码将比仅执行许多不同方法的代码运行得更快（由于内联缓存）。<br>
# 数组
##  数组存储模式
Fast Elements 是传统的线性存储方式，而 Dictionary Elements 使用的是 Hash 表存储。<br>
Fast Elements：该模式为默认模式，对于一个新创建的数组赋值时，数组的存储空间是可以动态增长的。<br>
Fast Holey Elements：还有一种子模式Fast Holey Elements，此模式适合于数组中只有某些索引存有元素，而其他的索引都没有赋值的情况（访问时引擎会返回 undefined）。<br>
Dictionary Elements：此方式最适合于存储稀疏数组，它不用开辟大块连续的存储空间，节省了内存，但是由于需要维护这样一个 Hash-Table。<br>
##  存储模式切换
其上的几种模式 V8 引擎可以自由切换。<br>
在 Fast Elements 模式下，capacity 用于指示当前内存占用量大小，通常根据数组当前最大索引的值确定。在数组索引过大，超过 capacity 到一定程度( 由 kMaxGap 决定，其值为 1024) ，数组将 直接转化为 Dictionary Elements 模式
##  数组性能优化
避免使用负整数作为索引<br>
预先指定数组大小<br>
避免使用不连续的索引值<br>
避免逆序对数组赋值<br>
[V8 引擎中的 JavaScript 数组实现分析与性能优化](https://blog.csdn.net/xiebaochun/article/details/85711635)
# JIT和AOT
##  AOT
AOT：静态编译的程序在执行前全部被翻译为机器码，通常将这种类型称为AOT （Ahead of time）即 “提前编译”，代表C/C++。
##  JIT
JIT：解释执行的则是一句一句边翻译边运行，通常将这种类型称为JIT（Just-in-time）即“即时编译”，代表JavaScript、python。

事实上所有脚本语言都支持JIT模式。但需要注意的是JIT和AOT指的是程序运行方式，和编程语言并非强关联的，有些语言既可以以JIT方式运行也可以以AOT方式运行，如Java、Python，它们可以在第一次执行时编译成中间字节码、然后在之后执行时可以直接执行字节码。