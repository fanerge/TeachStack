# XSS（Cross-site Script，跨站脚本）
```
// 原因
XSS 漏洞，通常指的是网站对用户输入数据未做有效过滤，攻击者可以将恶意脚本注入网站页面中，达到执行恶意代码的目的。
// 防御
1.  输入检查，白名单限制用户输入，<script>、javascript:、<、>、'、"、&、#，一定不要单纯只在客户端上做过滤，还要结合服务端做限制。若只是客户端上做过滤，那么抓包后修改数据重发就绕过了。
2.  输出检查
3.  innerHTML（textContent）、href、src、element.setAttribute、element.style.backgroundImage、
4.  Httponly Cookie、sameSite
5.  Content Security Policy
```
# SQL 注入
```
// 原因
开发时未对用户的输入数据进行有效过滤，直接带入 SQL 语句解析，使得原本应为参数数据的内容，却被用来拼接 SQL 语句做解析。 
一句话解释，错误的将数据当代码解析，最终导致 SQL 注入漏洞的产生。
// 防御
白名单：如果请求参数有特定值的约束，比如参数是固定整数值，那么就只允许接收整数；还有就是常量值限制，比如特定的字符串、整数值等。
参数化查询：参数化查询是预编译 SQL 语句的一种处理方式，所以也叫预编译查询，它可以将输入数据插入到 SQL 语句中的“参数”（即变量）中，防止数据被当作 SQL 语句执行，从而防止 SQL 注入漏洞的产生。
```
# CSRF（Cross Site Request Forgery，跨站请求伪造，也叫 XSRF）
```
// 原因
由于未校验请求来源，导致攻击者可在第三方站点发起 HTTP 请求，并以受害者的目标网站登录态（cookie、session 等）请求，从而执行一些敏感的业务功能操作。
// 防御
1.  Token 验证，提交表单后，会连同此 Token（隐藏的input） 一并提交，由服务器再做比对校验，Token 验证无疑是最常用的方法，它对用户是无感知的，体验上比验证码好太多了。
2.  令请求参数不可预测，所以常用的方法就是在敏感操作请求上使用 POST 代替 GET，然后添加验证码或 Token 进行验证。
3.  验证码，在一些重要的敏感操作上设置验证码（短信、图片等等），比如更改密码（此场景下也可要求输入原密码，这也是不可预测值）、修改个人资料等操作时。
```
# SSRF（Server-Side Request Forgery，服务端请求伪造）
```
// 原因
攻击者向服务端发送包含恶意 URL 链接的请求，借由服务端去访问此 URL ，以获取受保护网络内的资源的一种安全漏洞。
// 预防
1.  采用白名单限制，只允许访问特定的 IP 或域名，比如只允许访问 tabe 域名 *.tabe.cn；
2.  限制内网 IP 访问，常见的内网 IP 段有 10.0.0.0 - 10.255.255.255、172.16.0.0 - 172.31.255.255、192.168.0.0 - 192.168.255.255；
3.  禁用一些不必要的协议，比如 file://、gopher://(常用于攻击内网ftp、redis、telnet、smtp等服务)、dict://(常用于刺探端口)。
```
#  反序列化漏洞
```
// 反序列化：前面保存的字符串，快速地重建对象。
// 原因
当传给 unserialize() 的参数由外部可控时，若攻击者通过传入一个精心构造的序列化字符串，从而控制对象内部的变量甚至是函数，比如 PHP 中特殊的魔术方法，这些方法在某些情况下会被自动调用，为实现任意代码执行提供了条件，这时反序列化漏洞就产生了。
// 预防
1.  黑白名单限制/针对反序列化的类做一份白名单或黑名单的限制，首选白名单，避免一些遗漏问题被绕过。
```
# 文件上传漏洞
```
// 原因
文件上传漏洞正是在文件上传功能中，由于对用户上传的文件数据未做有效检测或过滤不严，导致上传的恶意文件被服务端解释器解析执行，利用漏洞可获取系统控制权。
// 预防
1. 严格检测上传文件后缀名、文件头（读取二进制文件，前几位表示文件类型），尽量采用白名单方式限制。
2. 重编码文件，比如对图片或视频做转换处理。
3. 限制文件大小，避免被恶意上传大文件造成存储空间不足，进而网站无法正常运行。
4. 限制上传目录可不解析，不同的服务器有不同的配置方式。
5. 上传文件重命名，建议使用随机文件名（可以防止文件包含漏洞）。
```
# 远程命令/代码执行漏洞RCE(remote command/code execute)
```
// 原因
服务端直接将接受到的数据传入到系统命令执行函数去执行（没有验证参数）。
system()exec()shell_exec()
以及多命令组合：cmd1 && cmd2、cmd1 | cmd2、cmd1 || cmd2、cmd1 ; cmd2
// 预防
1.  尽量不用系统命令执行函数，很多方式其实是可以通过一些语言内置 API 完成。
2.  如果一定要使用命令执行函数，就尽量不要将外部可控数据作为命令行参数（白名单限制）。
3.  命令执行监控与阻断，比如 PHP 环境下对 system 函数进行 hook。
```
# 文件包含漏洞（File Inclusion）
```
// 原因
首先“文件包含”，是一个功能。在各种开发语言中都提供了内置的文件包含函数，其可以使开发人员在一个代码文件中直接包含（引入）另外一个代码文件，但如果引入的文件受用户控制可就要当心了。
require(),require_once()
// 预防
1.  本地文件包含漏洞：仅能够对服务器本地的文件进行包含，由于服务器上的文件并不是攻击者所能够控制的，因此该情况下，攻击着更多的会包含一些 固定的系统配置文件，从而读取系统敏感信息。很多时候本地文件包含漏洞会结合一些特殊的文件上传漏洞，从而形成更大的威力。
2.  远程文件包含漏洞：能够通过url地址对远程的文件进行包含，这意味着攻击者可以传入任意的代码，这种情况没啥好说的，准备挂彩。
```
# 越权漏洞（over permission）
```
// 原因
越权漏洞是很多应用中比较常见的漏洞类型，它是在授权逻辑上存在安全缺陷导致的问题（水平越权、垂直越权）。
// 防御
1.  整体的权限调节：每次访问一个对象时，都要检查访问是否授权，特别是对于安全很关键的对象。
2.  最低权限原则：只授予执行操作所必需的最小访问权限，并且对于该访问权只准许使用所需的最少时间。
3.  前后端双重验证：在涉及敏感操作行为时，前端与后端同时对用户输入数据进行权限校验，尤其是前端校验特别容易被改包绕过。
```
# 点击劫持（clickJack）
```
// 原因
在网页中插入一个 transparent 的iframe，iframe 覆盖在定制位置，点击网页中的组件会触发 iframe 中的对应事件。
// 防御
1.  X-FRAME-OPTIONS: DENY 和 SAMEORIGIN，可以禁止或指定域名放入当前页面的 iframe 中。
2.  CSP frame-src 设置允许通过类似<frame>和<iframe>标签加载的内嵌内容的源地址。
```
